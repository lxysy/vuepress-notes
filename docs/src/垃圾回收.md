---
title: 垃圾回收
date: 2024-06-18
categories:
  - 垃圾回收
  - GC
tags:
  - GC
---

# 垃圾回收

​	JavaScript 是使用垃圾回收的语言，也就是说执行环境负责在代码执行时管理内存。在C和C++等语言中，跟踪内存使用对开发者来说是个很大的负担，也是很多问题的来源。JavaScript 为开发者卸下了这个负担，通过自动内存管理实现内存分配和闲置资源回收。基本思路很简单：确定哪个变量不会再使用，然后释放它占用的内存。这个过程是周期性的，即垃圾回收程序每隔一定时间（或者说在代码执
行过程中某个预定的收集时间）就会自动运行。

​	到了2008年，IE、Firefox、Opera、Chrome和 Safari都在自己的JavaScript实现中采用标记清理（或 其变体），只是在运行垃圾回收的频率上有所差异。

​	在浏览器的发展史上，用到过两种主要的 标记策略：标记清理和引用计数

## 标记清除

### 分代回收

V8 实现了准确式GC，GC算法方面采用了分代垃圾回收。

|          | 名称                             |
| -------- | -------------------------------- |
| 新生代GC | GC复制算法（Cheney的GC复制算法） |
| 老生代GC | GC标记-清除算法、GC标记-压缩算法 |

![分代](E:\book\img\分代.webp)

- V8 中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象；
- 新生区通常只支持 1～8M 的容量，而老生区支持的容量就大很多了；
- 对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收；

### 老生代MajorGC - 主垃圾回收器

​	经过多次新生代垃圾回收还存在的对象，同样的相比于新生代不仅垃圾回收频率较低，存储空间也是比新生代大的多。不过在v8中为了处理标记清除算法产生的内存碎片问题，使用了**GC标记-压缩算法**进行空间优化大大提高了回收效率。



GC标记-压缩算法由标记阶段和压缩阶段构成

1. 首先是标记。

   1. 从一组根元素开始，递归遍历这组根元素。
   2. 在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。

2. 然后是垃圾清除

   <img src="E:\book\img\垃圾清除.webp" alt="垃圾清除" style="zoom:75%;" />

3. 多次标记-清除后，会产生大量不连续的内存碎片，需要进行内存整理

   <img src="E:\book\img\压缩.webp" alt="压缩" style="zoom: 50%;" />

### 新生代MinorGC - 副垃圾回收器

​	分代垃圾回收的优点是只将垃圾回收的重点放在新生代对象身上，以此来缩减GC所需要的时间。不过考虑到从老年代对象的引用，结果还是要搜索堆中的所有对象，这样一来就 大大削减了分代垃圾回收的优势

- 负责新生代的垃圾回收，内存占用比较小，通常只支持 1~8 M 的容量。
- 新生代被分为两个区域：一般是对象区域，一半是空闲区域。

1. 先给对象区域所有垃圾做标记。
2. 标记完成后，存活的对象被复制到空闲区域

<img src="E:\book\img\新生代1.webp" alt="新生代1" style="zoom: 67%;" />

 3.复制完成后，对象区域会和空闲区域进行对调。将空闲区域中存活的对象放入对象区域里。



<img src="E:\book\img\新生代2.webp" alt="新生代2" style="zoom:67%;" />

一旦检测到空间装满了，就执行垃圾回收.。一个对象被多次复制还未被清理掉，故此对象会被认定为生命周期较长的对象，会被从新生代移动到老生代中，采用老生代的垃圾回收机制管理。

不过还需要注意一个特殊情况，如果新生代的复制一个对象到空闲区，如果空闲区的使用空间超过25%之后这个对象会被立即复制到老生代，而25%的红线要求是为了保证进行空闲区和使用区翻转时对于新的对象分配空间操作不会被影响。

> 综合来看，通过使用分代垃圾回收，可以改善GC所花费的时间（吞吐量）

## 引用计数

另一种没那么常用的垃圾回收策略是引用计数（reference counting）。其思路是对每个值都记录它被 引用的次数。声明变量并给它赋一个引用值时，这个值的引用数为1。如果同一个值又被赋给另一个变 量，那么引用数加1。类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减1。当一 个值的引用数为0时，就说明没办法再访问到这个值了，因此可以安全地收回其内存了。垃圾回收程序 下次运行的时候就会释放引用数为0的值的内存。 

> 优点：
>
> ​	1、实时回收，引用计数当归零就立即进行回收操作。
>
> ​	2、不会暂停执行栈，标记清除算法定时进行垃圾回收时会先暂停程序运行，来进行垃圾回收，而引用计数是实时回收不会暂停程序的运行
>
> 缺点：
>
> ​	1.  空间浪费，由于需要进行计数，所以需要开辟空间来存储计数器，同时由于引用无上限故占用空间也是无上限。
>
> ​	2. 无法解决循环引用无法回收(致命问题)，循环引用既两个引用类型AB，A有一个地址指向了B,B也有一个对象指向了A,导致两者引用技术为2，正常情况下当test函数运行结束进行垃圾回收，但是AB两者的基数都是不是0则回收失败，无法清除，这种情况大量发生时会造成大量的内存空间被浪费，故引用计数算法现在已经很少使用逐渐被标记清除算法替代。

## 增量式垃圾回收

通常的GC处理很繁重，一旦GC开始执行，不过多久应用程序(mutator)就没法执行了，这是常有 的事。也就是说，GC本来是从事幕后工作的，可是它却一下子嚣张起来，害得mutator这个 主角都没法发挥作用了。引擎将垃圾收集工作分成更小的块，每次处理一部分，多次处理。这样就解决了长时间停顿的问题。

![增量回收](E:\book\img\增量回收.png)

## 并发回收

虽然增量标记和惰性清理的出现使主线程停顿时间大大减少了，但是**总体的停顿时间**其实并未减少，如果真正细算起来甚至还增加了，应用程序的吞吐量也被降低，不过用户和浏览器的交互体验大大提升牺牲也是值得的。但是后续V8团队为了使回收更加高效， 又使用了并发回收机制，他是在主线程在执行程序任务时，主动开启辅助线程进行GC回收。而主线程又可以自由执行而不会挂起(标记操作全部由辅助进程操作)。

![并发回收](E:\book\img\并发回收.webp)
